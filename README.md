# SOS_Project
For this school project I implemented a deck of cards in Java and a playable game of blackjack using that deck. I wanted the deck to be as modular as possible, so that the same deck of cards could be used to implement a wide variety of card games. I chose Java as my implementation language because I have previous experience with it, and Java’s Object-Oriented nature is ideal for representing a deck object comprised of card objects. While Blackjack itself is not a very complicated game, implementing a modular deck of cards as well as the game logic and GUI for blackjack was a substantially large project for only six weeks. Below are excerpts from my final paper about the project.

###Introduction - Card, Hand and Deck classes:
I started by developing a Cards package, containing generic [Card](src/Card.java) and [Deck](src/Deck.java) classes, an abstract [Hand](src/Hand.java) class, and a simple GUI for blackjack. Because the heuristics for blackjack are so simple, I started by designing the GUI to interact with the game logic before trying to develop a more complex game.
Since the basic logical unit of a deck of cards is a single card, I started by designing the Card class, as well as a [CardsEnum](src/CardsEnum.java) class. This Enum class effectively assigns an absolute ordering of all the cards in a deck, to allow easy, in-order looping through a whole deck. The Enum class orders the deck from the two of spades up to the ace of hearts, with each card represented as a string of two chars - the suit followed by the number. For example, the two of hearts is represented by the string “H2.” This Enum class allows initialization of an array of integers of size 52, and because the cards have an absolute ordering from 0 to 51, each index of this array will correspond to a unique “card” in the deck. 
Each Card has to contain variables to represent its own name, corresponding image, value, getter and setter functions, as well as methods that allow it to interact with both a Deck and Hand Object. The way a Card interacts with both of these classes is different though, because of the way I designed each class. I designed a Hand to essentially be an array of cards, because a Hand usually contains a much smaller amount of cards than an entire deck. When designing the Deck class, I settled on a different structure.

###Initial Deck Implementation as an Array of References:
The final Deck class stores “Cards” as an array of integers, which I will discuss later. This, however, was not the first design strategy I used. Initially, I implemented the deck class as an array of Card objects. I chose to implement the deck as an array instead of a stack, even though it behaves essentially like a stack, because in card games, one usually only draws from the top of the pile. I didn’t use a stack because I wanted to have the ability to randomly access a card, perhaps for a future game where drawing from the middle of a deck would be desired behavior. 
This first implementation of my Deck class required a shuffle method, since the deck was populated in-order, by looping through the Enum class. To accomplish this shuffle, I used the Fisher-Yates shuffle algorithm, which is a short and easy way of randomizing an array of *n* objects. This operation would have been more expensive using a stack, which is another reason I used an array of integers. 
I eventually decided to implement the Deck using an array of integers instead of references. Each data structure has its own benefits and downfalls, but I decided on the array of integers primarily because of the comparative cost of the shuffle operation on an array of Card references. The array of cards was not the most efficient design, but every operation would run at about the same speed. I designed it so when a new deck was initialized, it was shuffled, which was a very expensive operation. The benefit of this design, however, was that after the initial expensive operation, the subsequent operations were always O(1), because I would just select the next card off the top of the array, and it would already be randomized.

###Final Deck Implementation as an Integer Array:
The array of integers, unlike the Card array, does not “shuffle” the deck when it is initialized, but every time a draw operation is performed, a random number is generated in the range 0-51, and the integer in the corresponding array index is decremented. If the integer selected is already at 0, indicating there are no more instances of this card left in the deck, another random number is generated. So, this implementation eliminates the very expensive shuffle method that I initially used, but now the draw method is more expensive than the O(1) draw I had before. 
On average, this implementation should perform faster than the Card array did. In certain scenarios, such as a deck that only has a few remaining cards in it, the draw method could perform slower than the original shuffle method, because it may have to generate many random numbers before a valid number in range is actually produced. In most cases, though, this algorithm will only need to generate a few random numbers to get a valid one. Another huge benefit of this implementation is that initializing a deck comprised of multiple decks is easier and much more memory-efficient. Initializing four decks still only requires an array of integers of size 52, whereas a Card array has to be an array of references of size 208.
The deck constructor takes an integer as an argument, which represents the number of decks you wish to initialize the deck to:
>Deck myDeck = new Deck(4);
The line above will initialize an array of integers (of size 52), so that each integer is set to 4. This implementation allows the user to play blackjack with as many decks as they want, which is how it is often played at a casino.

###The Hand Class:
In addition to the card and deck classes, I developed an abstract Hand class, which is really just an array of cards, but it has all the methods needed to interact with both the deck and the GUI. This class also has two subclasses, [playerHand](src/playerHand.java) and [opponentHand](src/opponentHand.java). These two are very similar, with the biggest difference being that opponentHand should display cards face-down in most cases, and the user should not be able to interact with opponentHand cards. The hand class interacts with the deck, so that when you draw a card from the deck, the deck is decremented and that card goes into the hand. The card class knows its own value, suit, whether it is face-up or face-down, card number (Card Enum value), and its corresponding image, which is just the two-character string (“H2”) followed by a “.png” extension.
The Hand class also must be aware of its total value, at least for Blackjack. This turned out to be more difficult than I expected, simply because Aces can either be evaluated to 1 or 11, depending on the game status, and the overall value of the hand. The difficulty for me stemmed from trying to figure out all the cases in which an Ace should be 1 and all the cases it should be 11. I designed it so that Aces now default to 11, unless the total value of the hand is over 21, in which case the hand changes the value of the first Ace it finds to a 1, and recalculates the hand value. This process will repeat until 21 is reached, or the player presses “Stay” (this case obviously only applies to cards in the playerHand class), or until there are no more Aces with a value of 11 remaining in the hand.

###The GUI:
I found a very helpful tool for GUI-design in Eclipse called WindowBuilder (from The Eclipse Foundation). It provides a drag and drop graphical interface so you can actually see the design you are creating, and any time you make a change in the graphical mode, it instantly makes the corresponding changes to the code. This makes it much easier to position images and text within a JFrame, because without the graphical interface, you just have to know which coordinates you want the image to display at.
I designed the Hand class to extend a JPanel, because it needs to display images of the cards it contains. Each hand is capable of displaying between 0-13 cards. I chose 13 because 12 is the maximum amount of cards one could draw in blackjack without going over 21, so a player could draw 12 and then one more which would result in a bust, but that card would need to be displayed first. 
Because I used Java's flowLayout for each container, the cards are displayed evenly-spaced within the container no matter how many cards there are. Each time a new card is drawn, all the cards in the deck are repainted so that they are evenly spaced. A minor problem with this, however, is that when a new card is added to a hand, it is sometimes drawn to the left and sometimes to the right. This is clearly not how a dealer would draw cards, but it is also not a major issue so I left it alone. 
Each hand displayed on the GUI will successfully draw cards from the deck and display the correct cards inside the container. The deck also displays the backs of cards stacked on top of each other (the deck image is actually just an image of multiple card backs stacked on top of each other which I made in GIMP). The player's cards all display face-up, and the opponent’s hand displays one face-down card and one face-up card. Each successive card drawn by the opponent, (or in this case, the “dealer”,) is displayed face-up. 
To finish the game’s functionality, I added “Hit”, “Stay”, “New Hand”, and “New Game” buttons, two JLabels that display the dealer and player score and two more JLabels that display the current total value of each hand. The “Hit” button will draw a card and update the total value of the hand. If the value of the hand reaches 21, the player wins and the “Hit” and “Stay” buttons are disabled. If the player goes over 21, the player loses and the buttons are disabled. The “Stay” button will disable the buttons for the player, and then initiate the dealer’s turn. After the dealer or player wins, the score is updated in the JLabel containing the score, and pressing “New Hand” will reset the game, but keep track of how many wins and losses the player has.
The “New Game” function took a lot of time to implement, because it has to reset the deck, the dealer hand and the player hands - which includes initializing a new deck and then drawing from that deck. Then it must display all the new cards, which requires everything in the GUI to be repainted, then the value of the new hands must be calculated. However, I didn’t want to have to call the hand constructors each time the player wanted to play a new game, so I created a new method called emptyHand, which allows me to reuse the same hand objects that were created when the GUI was first created, and populate the hand with different cards.

###Current Status/Bugs:
Currently, the game is functionally complete. The player can play as many hands of blackjack as they want, and the game will keep track of the overall wins and losses. All the buttons work correctly, and the game logic is mostly bug-free. There is a small bug that happens when the dealer draws more than one card, where the game will pause before drawing the cards and then display them all at once. This happens because I wanted to implement a pause after each draw to simulate a real person drawing from a deck. However, because of Java’s repaint manager, if there are multiple calls to the repaint() method in a short period of time, Java will compress all of these calls into one call to repaint() after everything has been updated. This is the only bug I have found after extensive testing.
